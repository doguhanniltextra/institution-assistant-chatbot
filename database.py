import sqlite3
import json
import datetime
import uuid
import os # Added for environment variable

# Determine database name: Use environment variable if set, otherwise default.
# This allows tests to use a different database.
DATABASE_NAME = os.environ.get('TEST_DATABASE_URL', 'chatbot_data.db')

def get_db_name():
    """Returns the current database name, primarily for testing purposes."""
    return DATABASE_NAME

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # Use a local variable for DATABASE_NAME to ensure it's fetched at connection time,
    # allowing it to be changed during tests if necessary (though module-level override is typical for pytest)
    db_name = os.environ.get('TEST_DATABASE_URL', 'chatbot_data.db')
    conn = sqlite3.connect(db_name)
    conn.row_factory = sqlite3.Row # Access columns by name
    return conn

def init_db(db_name_override=None):
    """Initializes the database and creates tables if they don't exist."""
    # Allow overriding DB name for initial setup, useful if called before env var is set by test runner
    current_db_name = db_name_override or DATABASE_NAME

    # Ensure connection uses the potentially overridden name for init_db specifically
    conn = sqlite3.connect(current_db_name)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    # Chat History Table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS chat_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        type TEXT,
        user_message TEXT,
        bot_response TEXT,
        details TEXT
    )
    ''') # details will store JSON string for extra info like city for weather etc.

    # Users Table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        name TEXT,
        title TEXT,
        department TEXT
    )
    ''')

    # Support Tickets Table
    # ticket_id is generated by the application (e.g. short UUID)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS support_tickets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        ticket_id TEXT UNIQUE NOT NULL,
        department TEXT,
        description TEXT,
        status TEXT DEFAULT 'open',
        priority TEXT DEFAULT 'normal',
        category TEXT DEFAULT 'general',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    ''')

    # Uploaded Reports Table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS uploaded_reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        original_filename TEXT NOT NULL,
        stored_filename TEXT UNIQUE NOT NULL,
        uploader_name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        processed INTEGER DEFAULT 0
    )
    ''')

    conn.commit()
    conn.close()

def seed_default_users():
    """Seeds 5 default internal profiles if table is empty."""
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT COUNT(*) FROM users')
    count = cur.fetchone()[0]
    if count and count > 0:
        conn.close()
        return
    default_users = [
        ("u-it-01", "Ali Yılmaz", "Kıdemli Yazılım Mühendisi", "IT"),
        ("u-ik-01", "Ayşe Demir", "İK Uzmanı", "İnsan Kaynakları"),
        ("u-muh-01", "Mehmet Kaya", "Muhasebe Uzmanı", "Muhasebe"),
        ("u-ts-01", "Zeynep Koç", "Teknik Servis Sorumlusu", "Teknik Servis"),
        ("u-op-01", "Can Arslan", "Operasyon Yöneticisi", "Operasyon")
    ]
    cur.executemany('INSERT OR IGNORE INTO users (id, name, title, department) VALUES (?, ?, ?, ?)', default_users)
    conn.commit()
    conn.close()

def get_users():
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT id, name, title, department FROM users ORDER BY name ASC')
    rows = [dict(row) for row in cur.fetchall()]
    conn.close()
    return rows

# --- Chat History Functions ---
def add_chat_history(user_id: str, type: str, user_message: str, bot_response: str, details_json_str: str = None):
    """Adds a new chat message to the history."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO chat_history (user_id, type, user_message, bot_response, details) VALUES (?, ?, ?, ?, ?)",
        (user_id, type, user_message, bot_response, details_json_str)
    )
    conn.commit()
    conn.close()

def get_chat_history(user_id: str, limit: int = 20) -> list:
    """Retrieves chat history for a user, ordered by timestamp descending."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM chat_history WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?",
        (user_id, limit)
    )
    history = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return history

# --- Support Ticket Functions ---
def add_support_ticket(user_id: str, ticket_id: str, department: str, description: str, priority: str, category: str):
    """Adds a new support ticket."""
    conn = get_db_connection()
    cursor = conn.cursor()
    now = datetime.datetime.now()
    cursor.execute(
        "INSERT INTO support_tickets (user_id, ticket_id, department, description, priority, category, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        (user_id, ticket_id, department, description, priority, category, now, now)
    )
    conn.commit()
    conn.close()

def get_support_tickets(user_id: str, limit: int = 50) -> list:
    """Retrieves support tickets for a user, ordered by creation date descending."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM support_tickets WHERE user_id = ? ORDER BY created_at DESC LIMIT ?",
        (user_id, limit)
    )
    tickets = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return tickets

def get_support_tickets_all(limit: int = 100) -> list:
    """Retrieves support tickets for all users with user info, newest first."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        """
        SELECT st.*, u.name as user_name, u.department as user_department
        FROM support_tickets st
        LEFT JOIN users u ON u.id = st.user_id
        ORDER BY st.created_at DESC
        LIMIT ?
        """,
        (limit,)
    )
    tickets = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return tickets

def update_support_ticket_status(user_id: str, ticket_id: str, status: str) -> bool:
    """Updates the status of a support ticket and its updated_at timestamp."""
    conn = get_db_connection()
    cursor = conn.cursor()
    now = datetime.datetime.now()
    cursor.execute(
        "UPDATE support_tickets SET status = ?, updated_at = ? WHERE user_id = ? AND ticket_id = ?",
        (status, now, user_id, ticket_id)
    )
    updated_rows = cursor.rowcount
    conn.commit()
    conn.close()
    return updated_rows > 0

def get_ticket_by_id(user_id: str, ticket_id: str):
    """Retrieves a specific ticket by its ID for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM support_tickets WHERE user_id = ? AND ticket_id = ?",
        (user_id, ticket_id)
    )
    ticket = cursor.fetchone()
    conn.close()
    return dict(ticket) if ticket else None

# --- Uploaded Reports Functions ---
def add_report(user_id: str, original_filename: str, stored_filename: str, uploader_name: str):
    """Adds a new uploaded report record and returns its ID."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO uploaded_reports (user_id, original_filename, stored_filename, uploader_name) VALUES (?, ?, ?, ?)",
        (user_id, original_filename, stored_filename, uploader_name)
    )
    report_id = cursor.lastrowid
    conn.commit()
    conn.close()
    return report_id

def get_reports(user_id: str = None, limit: int = 100) -> list:
    """Retrieves uploaded reports. If user_id is None, gets all reports."""
    conn = get_db_connection()
    cursor = conn.cursor()
    if user_id:
        cursor.execute(
            "SELECT * FROM uploaded_reports WHERE user_id = ? ORDER BY created_at DESC LIMIT ?",
            (user_id, limit)
        )
    else:
        cursor.execute(
            "SELECT * FROM uploaded_reports ORDER BY created_at DESC LIMIT ?",
            (limit,)
        )
    reports = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return reports

def get_report_by_id(report_id: int):
    """Retrieves a specific report by its ID."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM uploaded_reports WHERE id = ?",
        (report_id,)
    )
    report = cursor.fetchone()
    conn.close()
    return dict(report) if report else None

def mark_report_as_processed(report_id: int):
    """Marks a report as processed."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "UPDATE uploaded_reports SET processed = 1 WHERE id = ?",
        (report_id,)
    )
    conn.commit()
    conn.close()

def get_unprocessed_reports() -> list:
    """Retrieves all reports that have not been processed yet."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM uploaded_reports WHERE processed = 0 ORDER BY created_at ASC"
    )
    reports = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return reports

def delete_report(report_id: int):
    """Deletes a report record from the database and returns its stored filename."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # First, get the stored filename to return it for file deletion
    cursor.execute("SELECT stored_filename FROM uploaded_reports WHERE id = ?", (report_id,))
    report = cursor.fetchone()
    
    if not report:
        conn.close()
        return None

    stored_filename = report['stored_filename']

    # Delete the record from the database
    cursor.execute("DELETE FROM uploaded_reports WHERE id = ?", (report_id,))
    conn.commit()
    conn.close()
    
    return stored_filename

def reset_non_user_data():
    """Deletes all rows from app data tables but keeps users."""
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('DELETE FROM chat_history')
    cur.execute('DELETE FROM support_tickets')
    cur.execute('DELETE FROM uploaded_reports')
    conn.commit()
    conn.close()

if __name__ == '__main__':
    # For testing and initial setup
    print("Initializing database...")
    init_db()
    print("Database initialized.")

    # Example usage (optional, for testing)
    # add_chat_history("test_user_1", "llm", "Hello bot", "Hello user!", json.dumps({"confidence": 0.9}))
    # print(get_chat_history("test_user_1"))
    #
    # ticket_uuid = uuid.uuid4().hex[:8]
    # add_support_ticket("test_user_1", ticket_uuid, "IT", "My computer is broken", "high", "hardware")
    # print(get_support_tickets("test_user_1"))
    # update_support_ticket_status("test_user_1", ticket_uuid, "read")
    # print(get_ticket_by_id("test_user_1", ticket_uuid))
    #
    # add_report("test_user_1", "annual_report.pdf", "20230101_annual_report.pdf", "John Doe")
    # print(get_reports("test_user_1"))
    # print(get_reports())
    pass
