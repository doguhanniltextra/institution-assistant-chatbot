import sqlite3
import json
import datetime
import uuid
import os # Added for environment variable

# Determine database name: Use environment variable if set, otherwise default.
# This allows tests to use a different database.
DATABASE_NAME = os.environ.get('TEST_DATABASE_URL', 'chatbot_data.db')

def get_db_name():
    """Returns the current database name, primarily for testing purposes."""
    return DATABASE_NAME

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # Use a local variable for DATABASE_NAME to ensure it's fetched at connection time,
    # allowing it to be changed during tests if necessary (though module-level override is typical for pytest)
    db_name = os.environ.get('TEST_DATABASE_URL', 'chatbot_data.db')
    conn = sqlite3.connect(db_name)
    conn.row_factory = sqlite3.Row # Access columns by name
    return conn

def init_db(db_name_override=None):
    """Initializes the database and creates tables if they don't exist."""
    # Allow overriding DB name for initial setup, useful if called before env var is set by test runner
    current_db_name = db_name_override or DATABASE_NAME

    # Ensure connection uses the potentially overridden name for init_db specifically
    conn = sqlite3.connect(current_db_name)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    # Chat History Table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS chat_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        type TEXT,
        user_message TEXT,
        bot_response TEXT,
        details TEXT
    )
    ''') # details will store JSON string for extra info like city for weather etc.

    # Support Tickets Table
    # ticket_id is generated by the application (e.g. short UUID)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS support_tickets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        ticket_id TEXT UNIQUE NOT NULL,
        department TEXT,
        description TEXT,
        status TEXT DEFAULT 'open',
        priority TEXT DEFAULT 'normal',
        category TEXT DEFAULT 'general',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    ''')

    # Uploaded Reports Table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS uploaded_reports (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT NOT NULL,
        original_filename TEXT NOT NULL,
        stored_filename TEXT UNIQUE NOT NULL,
        uploader_name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    ''')

    conn.commit()
    conn.close()

# --- Chat History Functions ---
def add_chat_history(user_id: str, type: str, user_message: str, bot_response: str, details_json_str: str = None):
    """Adds a new chat message to the history."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO chat_history (user_id, type, user_message, bot_response, details) VALUES (?, ?, ?, ?, ?)",
        (user_id, type, user_message, bot_response, details_json_str)
    )
    conn.commit()
    conn.close()

def get_chat_history(user_id: str, limit: int = 20) -> list:
    """Retrieves chat history for a user, ordered by timestamp descending."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM chat_history WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?",
        (user_id, limit)
    )
    history = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return history

# --- Support Ticket Functions ---
def add_support_ticket(user_id: str, ticket_id: str, department: str, description: str, priority: str, category: str):
    """Adds a new support ticket."""
    conn = get_db_connection()
    cursor = conn.cursor()
    now = datetime.datetime.now()
    cursor.execute(
        "INSERT INTO support_tickets (user_id, ticket_id, department, description, priority, category, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        (user_id, ticket_id, department, description, priority, category, now, now)
    )
    conn.commit()
    conn.close()

def get_support_tickets(user_id: str, limit: int = 50) -> list:
    """Retrieves support tickets for a user, ordered by creation date descending."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM support_tickets WHERE user_id = ? ORDER BY created_at DESC LIMIT ?",
        (user_id, limit)
    )
    tickets = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return tickets

def update_support_ticket_status(user_id: str, ticket_id: str, status: str) -> bool:
    """Updates the status of a support ticket and its updated_at timestamp."""
    conn = get_db_connection()
    cursor = conn.cursor()
    now = datetime.datetime.now()
    cursor.execute(
        "UPDATE support_tickets SET status = ?, updated_at = ? WHERE user_id = ? AND ticket_id = ?",
        (status, now, user_id, ticket_id)
    )
    updated_rows = cursor.rowcount
    conn.commit()
    conn.close()
    return updated_rows > 0

def get_ticket_by_id(user_id: str, ticket_id: str):
    """Retrieves a specific ticket by its ID for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM support_tickets WHERE user_id = ? AND ticket_id = ?",
        (user_id, ticket_id)
    )
    ticket = cursor.fetchone()
    conn.close()
    return dict(ticket) if ticket else None

# --- Uploaded Reports Functions ---
def add_report(user_id: str, original_filename: str, stored_filename: str, uploader_name: str):
    """Adds a new uploaded report record."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO uploaded_reports (user_id, original_filename, stored_filename, uploader_name) VALUES (?, ?, ?, ?)",
        (user_id, original_filename, stored_filename, uploader_name)
    )
    conn.commit()
    conn.close()

def get_reports(user_id: str = None, limit: int = 100) -> list:
    """Retrieves uploaded reports. If user_id is None, gets all reports."""
    conn = get_db_connection()
    cursor = conn.cursor()
    if user_id:
        cursor.execute(
            "SELECT * FROM uploaded_reports WHERE user_id = ? ORDER BY created_at DESC LIMIT ?",
            (user_id, limit)
        )
    else:
        cursor.execute(
            "SELECT * FROM uploaded_reports ORDER BY created_at DESC LIMIT ?",
            (limit,)
        )
    reports = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return reports

if __name__ == '__main__':
    # For testing and initial setup
    print("Initializing database...")
    init_db()
    print("Database initialized.")

    # Example usage (optional, for testing)
    # add_chat_history("test_user_1", "llm", "Hello bot", "Hello user!", json.dumps({"confidence": 0.9}))
    # print(get_chat_history("test_user_1"))
    #
    # ticket_uuid = uuid.uuid4().hex[:8]
    # add_support_ticket("test_user_1", ticket_uuid, "IT", "My computer is broken", "high", "hardware")
    # print(get_support_tickets("test_user_1"))
    # update_support_ticket_status("test_user_1", ticket_uuid, "read")
    # print(get_ticket_by_id("test_user_1", ticket_uuid))
    #
    # add_report("test_user_1", "annual_report.pdf", "20230101_annual_report.pdf", "John Doe")
    # print(get_reports("test_user_1"))
    # print(get_reports())
    pass
